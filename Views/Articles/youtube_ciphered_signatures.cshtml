@section topheading
{
    Protection of Youtube streams
}

@section subheading 
{
    In-depth information
}

@section description
{
    This article is going to talk about how Youtube today protects their streams.<br />
    Acquiring stream information for a specific video is very easy. It is almost timeless.<br />
    What is not timeless is the constantly changing algorithm used to cipher stream signatures.<br />
    Youtube stores stream information in 2 main categories:<br />
    - url_encoded_fmt_stream_map is a collection of audiovisual streams. The maximum quality is 720p.<br />
    - adaptive_fmts is the collection of streams which are either video with image only, or audio. The high
    quality streams such as 1080p are stored here.<br />
    These category names are actual subkeys inside the configuration both mapping to an array of stream information.<br />
    Stream information comes in 2 different formats, but each can be parsed into JSON (get_video_info.php data needs some decoding first).<br />
    So the most important information associated with 1 single stream information is the "url", "s", "sts", and "js".<br />
    "s", if provided, is a ciphered signature: a long string of letters, numbers and a single dot in the middle.<br />
    In this case, the ciphered signature must be deciphered with the algorithm of unique id "sts".<br />
    Finally, the deciphered signature must be appended to the "url" as parameter "signature": {url_here} + "&signature={deciphered_signature}"<br />
    "s" is optional. If it does not exist, it means there is no ciphered signature. In this case, a working
    signature is already appended to "url", because whether there is ciphering or not, every "url" must include a signature.<br />
    Today, only VEVO videos' signatures are ciphered.<br />
    <br />
    Okay, but, how do I decipher the signature myself?<br />
    <br />
    The question is how Youtube deciphers the signature. The last important information is "js", which maps to the Youtube HTML5 player URL.<br />
    As with the ciphering algorithm, there are multiple versions of the player as well.<br />
    The function that deciphers the signature is built into its source code.<br />
    That means, a player can decipher signatures ciphered with 1 algorithm of id "sts".<br />
    That does not mean though there are not players with different ids that can decipher signatures ciphered with the same algorithm!
    The only thing it means is that the player ("js") present in the stream information can decipher signatures ciphered with the algorithm of id "sts" present in the same stream information.<br />
    <br />
    And how can I find the algorithm inside the player source?<br />
    <br />
    Well, this is something Youtube constantly changes. But I write how the algorithm can be traced back today.<br />
    In order to make this article timeless, I provide you with a sample video page source, get_video_info data, and player source code.<br />
    But I am not going to go into details here. If you want to see the debug info, the page source, the video player source, the URLs,
    the regexes used to finally get the algorithm that is also included then see the attachment below.<br />
    So in brief words, you need to find to which function the signature is passed on. That will be the decryption function.
    Then, you would want to find the body of this function. Today, the body of the function is a sequence of calls
    to functions which belong to objects. Actually, today all these crypto-related functions belong to 1 object. So the functions it calls are encapsulated in this object and are accessed through it.<br />
    The pattern looks like:<br />
    <br />
    {decryption_function_name} = { {object_name}.{object_function_name}( {signature}, {some_parameter} );<br />
    {object_name}["{object_function_name}"]( {signature}, {some_parameter}); ...... };<br />
    <br />
    Which, in practise looks like this: decrypt = { obj1.func1(signature, param1); obj1["func2"](signature, param2); ...... };<br />
    <br />
    So you need to look up the object and its given function in the same order.<br />
    And if you extract the body of such a function, then you should find Javascript functions "splice", "slice", and "reverse". At the time writing there is, however,
    1 function that does not contain 1 single JS function. That is usually referred to as "swap", because it is swapping the character at the first index with the character at the
    the index of the given parameter.<br />
    That's all as to ciphering.<br />
    <br />
    OK, and how do I obtain stream information?<br />
    <br />
    There are 2 ways of doing so. You can match the video page source against a regex to extract the embedded JSON configuration.<br />
    In this case, however, you have no control over how the signatures will be ciphered.<br />
    You get a player and an sts and you must find the algorithm.<br />
    Or, you can make an unofficial API call to get_video_info.php, which accepts "sts" as a parameter, and will cipher signatures in accordance with it.<br />
    BUT NOTE Youtube always creates new cipher algorithms, and deprecates older ones. That means, you will fail if you give an outdated "sts" as parameter.<br />
    Also, the data returned by get_video_info.php is encoded in a special way.<br />
    The data is an array of key-value pairs (JSON Object) delimited by "&". The key is separated from the value by "=".<br />
    This is Youtube's way of defining a JSON Object (Because the subsets/children are named/keyed).<br />
    Now you see that the JSON you just got is single-level. That is, the named subsets/children inside it seem to have no further subsets/children.<br />
    But actually there are 2 entries that have further children:<br />
    "url_encoded_fmt_stream_map" and "adaptive_fmts".<br />
    These are arrays of values (JSON Array), delimited by ",".<br />
    This is Youtube's way of defining a JSON Array (Because the subsets/children are unnamed/not keyed. Instead, they are just indexed).<br />
    So now you have 2 arrays, and I tell you each contains key-value pairs delimited by "&", wihich becomes apparent after performing
    an URL decoding on them.<br />
    You might have guessed it, but if not, the URL encoding is required not to mess up the organization of sets/children<br />
    Then you do 1 more URL decoding on the "url" but its splitting is not our task already but the server's ;)
}

@section btnname
{
    Debug info
}

@section url
{
    href="https://mega.nz/#!yFRxFISI!-ydt7UhFWtVz4Vcy4toHHog2_NhhjkosCGq3lp-Dg-k" target="_blank"
}