#pragma checksum "/Users/patrik.nusszer/Desktop/Nusstudios/Views/Articles/dijkstra.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "77e78f74574b07a78417fbfdd56205c8e4833d1a"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(AspNetCore.Views_Articles_dijkstra), @"mvc.1.0.view", @"/Views/Articles/dijkstra.cshtml")]
namespace AspNetCore
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
#nullable restore
#line 1 "/Users/patrik.nusszer/Desktop/Nusstudios/Views/_ViewImports.cshtml"
using Nusstudios;

#line default
#line hidden
#nullable disable
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"77e78f74574b07a78417fbfdd56205c8e4833d1a", @"/Views/Articles/dijkstra.cshtml")]
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"d2753723ec3b7f1744cac33670045c6f2e6d4ce3", @"/Views/_ViewImports.cshtml")]
    public class Views_Articles_dijkstra : global::Microsoft.AspNetCore.Mvc.Razor.RazorPage<dynamic>
    {
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
            DefineSection("keywords", async() => {
                WriteLiteral("\r\n    <meta name=\"keywords\" content=\"Dijkstra, graph, shortest path, nodes, proof, cycles, tree\" />\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("topheading", async() => {
                WriteLiteral("\r\n    Dijkstra\'s\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("subheading", async() => {
                WriteLiteral("\r\n    Shortest path finder algorithm\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("description", async() => {
                WriteLiteral(@"
    <p>
        Dijkstra's shortest path algorithm finds the shortest paths from a node to all the other nodes in a graph.<br>
        <br>
        A graph is an arrangement of nodes, where each node can have adjacent nodes or neighbours.<br>
        If 2 nodes are adjacent, they are connected with a weighted edge, a path with a length.<br>
        But with the term path we can describe a line connecting any number of nodes.<br>
        Such a line consists of any number of edges.<br>
        <br>
        We want to find the shortest path to each of the nodes from one node.<br>
        If there are more than 1 paths leading to any node of the nodes, it means you have a cycle.<br>
        You may not be able to traverse all the paths till they end from a given node inside a graph, because you might run into endless paths if there are cycles.<br>
        <br>
        And if there were not cycles, there would be no Dijkstra.<br>
        Because if there is no more than one path leading to a node, ");
                WriteLiteral(@"there are no endless loops and it would make no sense to search for shortest path, and you could walk all possible paths from a given node and eventually see it end at some node.<br>
        <br>
        The aim of Dijkstra is to remove these cycles, to leave only path of all the ones leading to every node, by selecting the shortest of them.<br>
        <br>
        After the removal of cycles, we will have something called a tree, which has no cycles in it.<br>
        And from the perspective of the node from which we want to retrive the shortest paths, it is a hierarchy, on top of which there this node, and for all other nodes of the hierarchy it is true that it can have only one ascendant, one edge upwards, towards the top node, and any number of descendants, edges downwards, towards the lower hierarchy levels.<br>
        This way it is even easier to see that there is exactly one possible way to the top node from any other node, because each node is derived from exactly 1 parent.<br>
        <br>");
                WriteLiteral(@"
        So we can say that the input of Dijkstra is a graph, and its output is a tree, which is from the perspective of our initial node can be viewed as a hierarchy with finite paths.<br>
        <br>
        The algorithm in fact is very easy to understand and to prove it indeed works.<br>
        I will use personal terminology.<br>
        <br>
        We are working with non-negative edge lengths.<br>
        <br>
        You have 2 sets to consider.<br>
        The ""closed"" set of nodes: the nodes for which the shortest path from the initial node has been determined.<br>
        The ""discovered/neighbouring open"" set of nodes or edges: for these nodes the shortest path from the initial node has NOT been determined yet, and these edges are the neighbours of ""closed"" nodes and the path length through the ""closed"" ascendant node has been discovered/temporarily saved/provisioned.<br>
        <br>
        We have to prove 2 things:<br>
        1) the set of ""closed"" nodes is correct<br>
      ");
                WriteLiteral(@"  2) the change to the set of ""closed"" nodes is correct<br>
        <br>
        Let's prove 2)<br>
        <br>
        We need to determine how long the path would be to any of the neighbouring ""open"" nodes of the ""closed"" nodes through themselves. (That means shortest path to closed node + edge length to neighbouring open node).<br>
        <br>
        If we close down the node with the shortest provisioned path, we can be sure it is the shortest path leading to the open discovered node, since assuming that any other ""discovered"" edge might lead to the same node, choosing the shortest equals shortest path.<br>
        <br>
        So we have proven that the changes made to a correct ""closed"" set of nodes is correct because we were looking at every possible candidate for shortest path continuation by looking at all open neighbours.<br>
        <br>
        We need to prove now that we can start out with a correct ""closed"" set of nodes.<br>
        <br>
        Let's prove 1)<br>
        <br>
");
                WriteLiteral("        The set of \"closed\" nodes at start includes the initial node with length zero, because it is the shortest path to itself, so our \"closed\" set is correct.<br>\r\n    </p>\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("btnname", async() => {
                WriteLiteral("\r\n\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("url", async() => {
                WriteLiteral("\r\n\r\n");
            }
            );
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<dynamic> Html { get; private set; }
    }
}
#pragma warning restore 1591
