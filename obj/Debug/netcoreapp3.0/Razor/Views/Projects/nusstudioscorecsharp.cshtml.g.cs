#pragma checksum "/Users/patrik.nusszer/nusstudios/Views/Projects/nusstudioscorecsharp.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "9d1568a1719f25492a249df509a590a5a0fd4e57"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(AspNetCore.Views_Projects_nusstudioscorecsharp), @"mvc.1.0.view", @"/Views/Projects/nusstudioscorecsharp.cshtml")]
namespace AspNetCore
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
#nullable restore
#line 1 "/Users/patrik.nusszer/nusstudios/Views/_ViewImports.cshtml"
using Nusstudios;

#line default
#line hidden
#nullable disable
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"9d1568a1719f25492a249df509a590a5a0fd4e57", @"/Views/Projects/nusstudioscorecsharp.cshtml")]
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"d2753723ec3b7f1744cac33670045c6f2e6d4ce3", @"/Views/_ViewImports.cshtml")]
    public class Views_Projects_nusstudioscorecsharp : global::Microsoft.AspNetCore.Mvc.Razor.RazorPage<dynamic>
    {
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
#nullable restore
#line 4 "/Users/patrik.nusszer/nusstudios/Views/Projects/nusstudioscorecsharp.cshtml"
  
    ViewData["Title"] = "Nusstudios.Core for C#";

#line default
#line hidden
#nullable disable
            WriteLiteral("\r\n");
            DefineSection("keywords", async() => {
                WriteLiteral("\r\n    <meta name=\"keywords\" content=\"core library, parsing, IO, common functions, JSON, Bencdoing, Unicode, reflection\" />\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("topheading", async() => {
                WriteLiteral("\r\n    Nusstudios.Core\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("subheading", async() => {
                WriteLiteral("\r\n    A general purpose library\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("description", async() => {
                WriteLiteral(@"
    This library contains the most common functions I use while programming C#.<br>
    <br>
    It has a simple B encode / B decode static class.<br>
    It has a JSON parser with 4 major functions: Query, Update, Delete, Exists.<br>
    You can query deep clones/references of managed types, and also reference returns aka aliases for unmanaged primitives.<br>
    Every built-in basic primitive type is converted to the library's managed equivalent though.<br>
    That means if you query a reference to an integral type or string instead of an alias, you can use an instance method to update the primitive type they encapsulate.<br>
    The Update function will either put the reference/deep clone of the variable into the JSON container.<br>
    Delete, Update, Query will each accept compound paths to any node inside the hierarchy.<br>
    It contains an IO library with a function that walks directory structures reporting every node (files and directories).<br>
    <br>
    It also has a more general ");
                WriteLiteral(@"dynamic hierarchy manager, which enables you to add to and query from the hierarchy literally any type that inherits from class object.<br>
    <br>
    This library is highly object-oriented. My generic Map class is a remake of the reference implementation of the
    built in generic dictionary.<br>
    A Map object is encapsulated by 3 concrete specialised classes: StringContainer, ArrayContainer, NumericContainer.<br>
    StringContainer is sort of a dictionary with alphanumeric (string)keys and object values.<br>
    ArrayContainer has integer keys and they must follow an array-like order.<br>
    NumericContainer also has integer keys, but they are not bound to follow an array-like order.<br>
    These 3 container types all inherit from the abstract Container class. You can either query values
    by specifying an object key, or you pass a key as argument to one of the generic instance functions.<br>
    Either way is used, it is verified whether the type of the specified key matches the key ty");
                WriteLiteral(@"pe
    required by the current concrete type assigned to that abstract Container.<br>
    Container also implements the IEnumerable interface so that it can be used with foreach compound statements.<br>
    JValue is an abstract class with a static Parse function. The JContainer and JLeaf abstract classes inherit from it directly.<br>
    JObject and JArray are conrete direct successors of JContainer. They encapsulate the aforementioned StringtContainer and ArrayContainer classes, respectively.<br>
    JLeaf is inherited by the abstract class ManagedNumber, concrete classes ManagedString, ManagedBoolean and ManagedNull.<br>
    ManagedNumber is inherited by the abstract classes ManagedInteger and ManagedRational.<br>
    ManagedInteger is then inherited by abstract classes ManagedSignedInteger and ManagedUnsignedInteger.<br>
    These 2 classes are then inherited by concrete classes ManagedInt32, ManagedUInt8, etc...<br>
    ManagedRational is inherited by ManagedDouble, ManagedBigRational, etc...<br");
                WriteLiteral(@">
    The abstract classes provide seamless conversion between each type. If a conversion is possibly lossy,
    then it is essentially explicit. Otherwise the conversion is implicit.<br>
    <br>
    It has a Unicode parser that can encode code points and decode code units. Supports every Unicode version,
    UTF-8, UTF-16, UTF-32, and it is endianness aware.<br>
    It also has an UnicodeStream class which functions like a StringBuilder except that it encapsulates an array
    of code points instead of chars. The number of characters is equal to the length of the UnicodeStream, unlike in
    case of strings. There is seamless conversion between strings and UnicodeStreams.<br>
    There are other additional functions that resemble the additional string functions you have:
    you can determine whether an UnicodeStream is numeric, alphanumeric, hexadecimal; you can convert a UnicodeStream
    to integral and fraction, etc...<br>
    There are some type-specific utilities for arrays and strings. Yo");
                WriteLiteral(@"u can for example find the first and last index
    of a subarray inside an array and stuff like that.<br>
    It contains StringMath, a very basic math library for string variables.<br>
    It has a base converter that converts a fraction from a base into another (up to base 16).<br>
    There is a byte array to integer/double and integer/double to byte array converter class that you can
    configure with endianness. It can read variable encoded unsigned integers as well.<br>
    For every method there are 2 approaches: one that calculates the return value by maths,
    and the one which strictly uses bit shiftings.<br>
    There is a Console class that registers each writing to the console,
    marks them as required and clears/updates them without unexpected behaviour.<br>
    It is really reliable given that the console window is not resized (Please no resize!).<br>
    Contains all the reference implementations of hash functions of .NET. And extends it with
    the new born Keccak. You can c");
                WriteLiteral(@"hoose to use the original or the standardized padding.<br>
    And finally there is a bit handling utility which you can use to quickly access certain bits
    in a byte. A function will return a sequence of bits from a byte array given a byte position,
    bit position (little endian-like), requested number of bits, and whether you are reading towards
    the most or the least singificant bit. There is a write function with similar parameters to insert a sequence
    of bits into a byte array.<br>
    It also includes an Object extension which enables deep cloning of any object. Please note this one is not my
    work, I just copied it.
");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("source", async() => {
                WriteLiteral("\r\n    href=\"https://github.com/patriknusszer/Nusstudios.Core\" target=\"_blank\"\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("release", async() => {
                WriteLiteral("\r\n    href=\"https://github.com/patriknusszer/Nusstudios.Core/raw/master/Nusstudios.Core/bin/Release/netstandard2.1/Nusstudios.Core.dll\" target=\"_blank\"\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("projectspecs", async() => {
                WriteLiteral("\r\n    C# .NET Standard 2.1 library. Version 1.1.\r\n");
            }
            );
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<dynamic> Html { get; private set; }
    }
}
#pragma warning restore 1591
