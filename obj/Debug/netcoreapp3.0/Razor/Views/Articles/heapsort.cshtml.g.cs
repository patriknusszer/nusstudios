#pragma checksum "/Users/patrik.nusszer/nusstudios/Views/Articles/heapsort.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "04344811b3e82d724bcc4b0d0c76e9ffbe2a50cc"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(AspNetCore.Views_Articles_heapsort), @"mvc.1.0.view", @"/Views/Articles/heapsort.cshtml")]
namespace AspNetCore
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
#nullable restore
#line 1 "/Users/patrik.nusszer/nusstudios/Views/_ViewImports.cshtml"
using Nusstudios;

#line default
#line hidden
#nullable disable
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"04344811b3e82d724bcc4b0d0c76e9ffbe2a50cc", @"/Views/Articles/heapsort.cshtml")]
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"d2753723ec3b7f1744cac33670045c6f2e6d4ce3", @"/Views/_ViewImports.cshtml")]
    public class Views_Articles_heapsort : global::Microsoft.AspNetCore.Mvc.Razor.RazorPage<dynamic>
    {
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
            DefineSection("keywords", async() => {
                WriteLiteral("\r\n    <meta name=\"keywords\" content=\"heapsort, onlogn, binary heap, max min heap, heapify\" />\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("topheading", async() => {
                WriteLiteral("\r\n    Heaposrt\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("subheading", async() => {
                WriteLiteral("\r\n    O(nlogn) sorting algorithm\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("description", async() => {
                WriteLiteral(@"
    <article>
        <p>
            Heapsort was invented by John William Joseph Williams
        </p>
        <p>
            Heapsort has a deterministic O(nlogn) running time, with this being one of the 3 fastest sorting algorithms, and among those the slowest due to the cache misses caused by the arbitrary array jumps.<br/>
            Unlike the other 2 O(nlogn) sorting algorithms, heapsort does not implement the divide and conquer approach.<br/>
            It is an in-place (and instable) sort with O(1) memory complexity, which operates on the same input array, but handles it like it was a complete binary tree, a maximum or minimum heap.<br/>
            This is the thing which makes it so fast, so much faster than a selection sort, for example.
        </p>
        <p>
            A complete binary tree is a binary tree in which every level is complete, and only the lowest level can be an exception from this, which must fill the leftmost part of that level given its indeed incomplete.<b");
                WriteLiteral(@"r/>
            The nodes in this complete binary tree are in the same order as the characters of the text of a page in a book as you are reading it.<br/>
            But here, instead of lines of text, you have levels.<br/>
            The top node or root is at position 0 = (2^0 - 1), then its leftmost child is at position 1, and then its rightmost child is at position 2.<br/>
            Following that analogy, the leftmost child of the leftmost child of the root node is at position 3 (= 4 - 1), and the leftmost child of that node must be then at position 7 (= 8 - 1).<br/>
            That is because,Â in order to get the position of leftmost node on level n, you need to calculate:<br/>
            <br/>
            2^0 + 2^1 + 2^2 + 2^3 + ... + 2^(n-1) = leftmost node on level n<br/>
            <br/>
            Note: both the nodes and levels are indexed based on zero, meaning that n = 0 means level 1<br/>
            <br/>
            The formula basically adds up the number of nodes on all p");
                WriteLiteral(@"revious levels to get to the index of the first node on level n.<br/>
            <br/>
            So for example, if n = 1 (level 2), then index = 2^0 = 1, because we add up the level 1 only.<br/>
            Or for example, if n = 3 (level 4), then index = 2^0 + 2^1 + 2^2 = 7, because we add up level 1, level 2, and level 3 to get index of first node at level 4.<br/>
            <br/>
            This means that, if we are looking at the indices of the leftmost nodes on each level, we see powers of 2 minus one: 0, 1, 3, 7, 15, etc... Can we prove that?
        </p>
        <p>
            When proving the height of an AVL tree, we have already seen the exact same proof.<br/>
            The generalisation of that proof is we want to show that adding up subsequent powers of 2 plus 1, we get a power of 2 as a result.<br/>
            <br/>
            2^0 + 2^1 + 2^2 + 2^3 + 2^4 + ... + 2^(n-1) = x<br/>
            2^1 + 2^1 + 2^2 + 2^3 + 2^4 + ... + 2^(n-1) = x + 1<br/>
            2 * (2^1 + 2");
                WriteLiteral(@"^1 + 2^2 + 2^3 + ... + 2^(n-2)) = x + 1<br/>
            2 * (2 * (2^1 + 2^1 + 2^2 + ... + 2^(n - 3))) = x + 1<br/>
            2^n = x + 1<br/>
            <br/>
            That is because 1 factorisation takes away 1 additive, and there are n additives all in all.<br/>
            <br/>
            Which means 2^n-1 = x = index of leftmost child on level n
        </p>
        <p>
            Okay, so why am I showing all this?<br/>
            Because in heapsort algorithm, we will only want to do one thing while traversing the input array as if it was a binary tree: we want to get the position of the left immediate child node of a node at a given index in constant time.<br/>
            How do we do that?<br/>
            <br/>
            We know 2 things:<br/>
            - The immediate child is on the one lower immediate level<br/>
            - The immediate left child is preceded by exactly 2 times the number of nodes left to its parent, because all of them have exactly 2 children on");
                WriteLiteral(@" the 1 lower immediate level<br/>
            <br/>
            So let's say that we have a node at position p.<br/>
            We have an imaginary resolution for p:<br/>
            (2^n - 1) + x = p, and p < 2^(n + 1) - 1<br/>
            Where n is the index of the level on which the node resides.<br/>
            Where x is the zero-based index of node n, such that it is also the number of nodes left to it on the same level.
            <br/>
            In order to get to the left child node of a node, you will want to add up the number of nodes above it, and multiply the number of nodes left to its parent.<br/>
            And that is exactly the position of the parent node multiplied by 2, plus 1.<br/>
            <br/>
            Because p is the position of the parent, and<br/>
            2 * p = 2 * (2^n - 1) + 2 * x = 2 * ((2^n - 1) + x)<br/>
            2 * p = 2^(n+1) - 2 + 2x<br/>
            2 * p + 1 = 2(n+1) - 1 + 2x<br/>
            <br/>
            And that is the proof");
                WriteLiteral(@".<br/>
            Because 2^n - 1 is the position of the leftmost node of that level on which the parent node is, and therefore 2^(n+1) - 1 is the position of the leftmost node of the level just below it.<br/>
            And you need to add 2 times x more to that, because x is the number of nodes which precede the parent node, and since it is a complete binary tree whose leftmost part is always complete, 2 children per every node preceding the parent precede its left immediate child.<br/>
            <br/>
            And knowing that 2 * index + 1 equals the left immediate child of the node at a given index, plus 1 will equal the right immediate child.
        </p>
        <p>
            So where does heapsort use that formula?<br/>
            <br/>
            It has a recursive max_heapify() or min_heapify() function.<br/>
            A max_heapify() based heapsort produces a maximum heap, where both children of a node are smaller (or equal), and a min_heapify() based one produces a minimum h");
                WriteLiteral(@"eap, where the children of a node are both larger (or equal).<br/>
            <br/>
            So in case of a max/min heap, wherever you look, the root node of any subtree of a tree will be the largest/smallest element in that whole subtree.<br/>
            <br/>
            The heapify functions are able to heapify such a (sub)tree in which only the apex/top node is at wrong position in relation to other nodes of that (sub)tree.<br/>
            That essentially means, the 2 subtrees branching out of that node must be heapified/ must be already completely valid binary heaps.<br/>
            <br/>
            In that case, such a heapification takes at worst O(logn) time, where n is number of nodes that subtree, and logn is the height of the subtree.<br/>
            <br/>
            Because the height of any complete binary tree is always logn, because the number of nodes in a binary tree is a sum of incremental powers of 2, and such a sum plus 1 is also a power of 2.<br/>
            In term");
                WriteLiteral(@"s of Big-O where constants are neglected, the plus 1 one is neglected, and it is fair enough.<br/>
            <br/>
            And so such a heapification takes O(logn) because what it does is just swapping nodes vertically, and never steps backwards, hence O(logn).<br/>
            <br/>
            On first occasion, you will need to perform heapification on every array element, starting from the nodes of the lowest level (minus 1 of course, because lowest level only consists of leaf nodes), so that you can heapify larger and larger subtrees based on the already heapified smaller subtrees on the lower level.<br/>
            <br/>
            This initial heapification will take you of course O(nlogn), since you are performing O(logn) operations for almost every node.<br/>
            <br/>
            Let's say you have the following tree with the following nodes:<br/>

            A                   (1)<br/>
            BC                  (2)<br/>
            DEFG                (4)<br/>
");
                WriteLiteral(@"            HIJKLMNO            (8)<br/>
            PQRSTUVWXYZ01234    (16)<br/>
            <br/>
            First, you would heapify the subtrees HIJKLMNO, and you can do so, since by definition, their children are already heapified, since they are not real subtrees, they are all leaf nodes.<br/>
            Now you could then heapify subtrees DEFG because subtrees HIJKLMNO are already heapified.<br/>
            Then, you could heapify subtrees BC, because subtrees DEFG are already heapified.<br/>
            And finally, you could then heapify tree A, because subtrees BC are already heapified.
        </p>
        <p>
            So let's prove heapify functions actually work like that!<br/>
            1) We have an initial state:<br/>
            We have a subtree, and its 2 branches, and in both, the nodes inside are in correct relative position, meaning they are both independent, but are correct binary heaps on their own.<br/>
            <br/>
            2) Prove that, the change to ");
                WriteLiteral(@"this state produces another correct state, which is 1 correct binary heap with all elements being in correct position relative to each other!
        </p>
        <p>
            A single heapify call will restore a node and its 2 immediate children into correct relative position, meaning it will generate a correct local binary heap at that aggregate of nodes.<br/>
            If we have a maximum heap, it is determined which of the 3 elements is the largest.<br/>
            Given the largest element is one of the children nodes, it takes the top position and the other 2 are made to be the its children:<br/>
            <br/>
            Before:<br/>
            5<br/>
            47<br/>
            <br/>
            After:<br/>
            7<br/>
            45<br/>
            <br/>
            So yes, 1 heapify call indeed succeeds in creating a mini triangle which is a correct binary tree.<br/>
            It is said that, that largest element is bubbled up, while the smaller top element");
                WriteLiteral(@" is bubbled down to take its place.
        </p>
        <p>
            A heapify can be safely performed on any binary tree, in which there is only 1 node which is in some incorrect position to some other nodes subordinate to it in the heap.<br/>
            First off, of course, this incorrect node is the apex of the subtree which we are looking at, but whenever it is bubbled down to a lower level, we get another binary heap in which all nodes except that node are in correct position relative to each other, and the bubbled down node may only be in incorrect position relative to its subordinates - so it is always in correct position relative to its superordinates inside that subtree - until that we will continue bubbling it down, until it either hits the end of the tree at which point it simply can not be any longer at incorrect position relative to subordinates, or until, the 1 subordinate is found to be in correct position relative to it, at which point all indirect subordinates must also be in correc");
                WriteLiteral(@"t position relative to it.
        </p>
        <p>
            1) Here, safe means on 1 hand, that bubbling up a node does not put that node into an incorrect position relative to any other (sub)tree nodes, if it was in correct position to all of them before, since its former immediate children are still subordinate to it, but now indirectly, and all its former indirectly superordinate nodes are still superordinate, the closest now being immediate parent to it.<br/>
            2) Safe means, on the other hand, bubbling down a node does not put that node into an incorrect position relative to its former superordinate nodes, which are still superordinate to it, though all of them indirectly.<br/>
            3) Safe also means all other nodes stayed at their place, therefore they are at correct positions relative to each other
            4) However, the bubbled down node can still be at incorrect position relative to its subordinate nodes
        </p>
        <p>
            That means, whenever we ");
                WriteLiteral(@"call heapification for the same node, it turns a subordinate which is in incorrect position relative to it into its immediate parent whcih must be at correct position now relative to it, and it is recursively applied up until:<br/>
            <br/>
            1) none of the new immediate children of the bubbled down node are in incorrect position relative to it, which of course also means none of its indirect children are at incorrect position relative to it<br/>
            2) it has no children, because we have arrived at the end of the tree, so it must be at correct position<br/>
            <br/>
            That means, this constantly bubbled down node eventually gets into correct position relative to all other elements in that subtree which we were looking that, so the change made to our initial state indeed produces another correct state.
        </p>
        <p>
            Since we are constantly bubbling down a node vertically, it is also proven that in worst case we are doing as many oper");
                WriteLiteral(@"ations as tall the subtree was, which is O(logn) in worst case.<br/>
            <br/>
            So we can build a binary heap out of our input array in O(nlogn).<br/>
            <br/>
            Building a minimum heap is exactly the same story, but instread you are looking for smallest element out of the 3 and bubble that up, while bubbling the apex down to its place.
        </p>
        <p>
            But that is only half of the story.<br/>
            <br/>
            Now you are sure that the largest element of the array is the apex.<br/>
            That is the zeroth index of the array.<br/>
            It would be too easy to just put the resulting numbers into a new array.<br/>
            We are going to do it in place.<br/>
            You swap this apex with the element at the last array index, wich is the rightmost node on the lowest level.<br/>
            Now you heapify the tree at its apex again, to bubble down that small number you have just put there, but you specify a");
                WriteLiteral(@" 1 smaller array length, so that heapify is not going to bother the largest number you have placed at the largest index.<br/>
            After heapification, you will have the largest node of the 1 smaller tree at the top position, but since this new tree was basically the largest plus all the rest, the largest of the rest is going to be the second largest.<br/>
            And again, you swap the apex with the node at the end of the last array index minus one, which is anyway the end of the 1 smaller heap we are considering in this second step.<br/>
            And you continue doing it, until you have an array with a length of at least 3 nodes.<br/>
        </p>
        <p>
            So this second part of heapsort will take you another O(nlogn) operations, and since you have O(nlogn) for first part, and O(nlogn) for second, you also have eventually O(nlogn).
        </p>
    </article>
");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("btnname", async() => {
                WriteLiteral("\r\n\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("url", async() => {
                WriteLiteral("\r\n\r\n");
            }
            );
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<dynamic> Html { get; private set; }
    }
}
#pragma warning restore 1591
