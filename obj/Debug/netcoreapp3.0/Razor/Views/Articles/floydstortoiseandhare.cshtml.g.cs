#pragma checksum "/Users/patrik.nusszer/nusstudios/Views/Articles/floydstortoiseandhare.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "41dde1fc6e0dc1fb39710ce12200ff4c062e4da4"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(AspNetCore.Views_Articles_floydstortoiseandhare), @"mvc.1.0.view", @"/Views/Articles/floydstortoiseandhare.cshtml")]
namespace AspNetCore
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
#nullable restore
#line 1 "/Users/patrik.nusszer/nusstudios/Views/_ViewImports.cshtml"
using Nusstudios;

#line default
#line hidden
#nullable disable
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"41dde1fc6e0dc1fb39710ce12200ff4c062e4da4", @"/Views/Articles/floydstortoiseandhare.cshtml")]
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"d2753723ec3b7f1744cac33670045c6f2e6d4ce3", @"/Views/_ViewImports.cshtml")]
    public class Views_Articles_floydstortoiseandhare : global::Microsoft.AspNetCore.Mvc.Razor.RazorPage<dynamic>
    {
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_0 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("src", new global::Microsoft.AspNetCore.Html.HtmlString("~/js/algos/floyd.js"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_1 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("rel", new global::Microsoft.AspNetCore.Html.HtmlString("stylesheet"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_2 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("type", new global::Microsoft.AspNetCore.Html.HtmlString("text/css"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_3 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("href", new global::Microsoft.AspNetCore.Html.HtmlString("~/css/algos/floyd.css"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        #line hidden
        #pragma warning disable 0649
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperExecutionContext __tagHelperExecutionContext;
        #pragma warning restore 0649
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperRunner __tagHelperRunner = new global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperRunner();
        #pragma warning disable 0169
        private string __tagHelperStringValueBuffer;
        #pragma warning restore 0169
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperScopeManager __backed__tagHelperScopeManager = null;
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperScopeManager __tagHelperScopeManager
        {
            get
            {
                if (__backed__tagHelperScopeManager == null)
                {
                    __backed__tagHelperScopeManager = new global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperScopeManager(StartTagHelperWritingScope, EndTagHelperWritingScope);
                }
                return __backed__tagHelperScopeManager;
            }
        }
        private global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper;
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
            DefineSection("keywords", async() => {
                WriteLiteral("\r\n    <meta name=\"keywords\" content=\"linear time, FLoyd\'s tortoise and hare, proof, algorithm, cycle detection, tail, cycle, loop\" />\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("topheading", async() => {
                WriteLiteral("\r\n    Floyd\'s tortoise and hare\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("subheading", async() => {
                WriteLiteral("\r\n    Linear time cycle detection algorithm\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("special", async() => {
                WriteLiteral("\r\n    ");
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("script", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagAndEndTag, "41dde1fc6e0dc1fb39710ce12200ff4c062e4da45058", async() => {
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_0);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                WriteLiteral("\r\n    ");
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("link", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagOnly, "41dde1fc6e0dc1fb39710ce12200ff4c062e4da46143", async() => {
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_1);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_2);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_3);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                WriteLiteral("\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("description", async() => {
                WriteLiteral(@"
    <article>
        Floyd's tortoise and hare is a cycle detection algorithm.<br>
        It is in fact unclear who came up with it first, the name is based on assumptions.<br>
        <br>
        You have a list of nodes.<br>
        The 'last' node is linked to one of the earlier nodes in the list.<br>
        This breaks it into a tail and a cycle, where the tail, a line of nodes runs into a circle of nodes.<br>
        <br>
        We need to find the node where the tail intersects the circle, which we will call cycle entry point/node.<br>
        <br>
        The algorithm does not keep account of any numbers, the only thing we know is when the 2 iterators traversing the node list meets at the same node.<br>
        We have a rabbit (hare) and a turtle (tortoise), the former covers twice the distance of the turtle's, which travels node by node.<br>
        Entering the node means you are revolving around the cycle for the time being.<br>
        Since we have such a cycle, which may be ");
                WriteLiteral(@"completely traversed a multiple of times, we need to talk in terms of modulo arithmetics.<br>
        <br>
        Let T be the tail length, and C be the cycle length.<br>
        <br>
        r = T mod C<br>
        <br>
        Which means:<br>
        T = k*C + r<br>
        Where 'k' is a natural number, and 'r' is the remainder for which it is true that (r < C)<br>
        <br>
        Let's assume that 'r' equals zero.<br>
        It means that the 2 pointers can not meet until turtle covers (T - 1) distance.<br>
        But it also means that they must meet at the cycle entry point when turtle has covered T distance.<br>
        That is because T % C = 0 in this case.<br>
        We do not stop there of course, because we can not always assume that 'r' is zero.<br>
        What we must do because of this uncertainty, is we set one of the pointers back to the first (head) node of the list.<br>
        We set the speed of both to node by node (1x) and of course it is no surprise they will");
                WriteLiteral(@" meet again at the cycle entry node.<br>
        <br>
        The reason why we in fact need this second step is because 'r' may not be zero with (C-1)/C probability ratio.<br>
        So let's consider this case.<br>
        <br>
        This means that the 2 pointers can not meet until turtle covers (T - 1) distance, just like in the former case.<br>
        But here it also means the 2 pointers can not meet until turtle covers T distance, because 'r' is not zero.<br>
        <br>
        We need some proof that tells us these 2 pointers will indeed meet at some significant node for the first time.<br>
        There is a less proofish but still formal and very clear method to tell where they meet the first time.<br>
        <br>
        So when turtle has covered T distance, it is exactly at node zero of the cycle, where node zero is the cycle entry node.<br>
        At the same time rabbit is at some node 'r' of the cycle.<br>
        That means rabbit is 'r' ahead of the turtle, but it also m");
                WriteLiteral(@"eans turtle is (C - r) ahead of rabbit.<br>
        Now since rabbit has 2x speed, it will take another (C - r) distance to be covered by the turtle for the 2 to meet the first time.<br>
        <br>
        d + (C - r) = 2 d<br>
        => d = C - r<br>
        <br>
        So it means the 2 pointers will meet at node (C - r) of the cycle because turtle covered (C - r) nodes from node zero.<br>
        It is significant because it also means that the cycle entry node is 'r' ahead of that node.<br>
        <br>
        We can set up a less intuitive but maybe rather proofish equation for this:<br>
        <br>
        d = 2d + r (mod C)<br>
        Let d = l*C + a<br>
        Where (a = d mod C), so that (a < C) and 'l' is natural number<br>
        <br>
        l*C+a = 2(l*C+a) + r (mod C)<br>
        We are translating modulo to subtraction in next step.<br>
        <br>
        l*C+a - l*C = 2a+2lC + r - ((2l+e)*C)<br>
        We can tell modulo would subtract at least 2lC from left hand");
                WriteLiteral(@" side but not how much more.<br>
        This unknown extra subtraction is denoted by 'e' which is a natural number<br>
        <br>
        a = 2a + r - e*C<br>
        <br>
        Eventually we get:<br>
        e*C = a + r<br>
        <br>
        We know that (a < C) and (r < C)<br>
        => a + r < 2*C<br>
        <br>
        Which means<br>
        => e*C < 2*C<br>
        e < 2<br>
        <br>
        From that it follows<br>
        => 'e' is either zero or one<br>
        <br>
        Therefore we need to find solution for:<br>
        1) 0*C = 0 = a + r<br>
        2) 1*C = C = a + r<br>
        <br>
        We have already considered the case when 'r' is zero, but if it is not zero, equation 1) should not be considered.<br>
        <br>
        In case of equation 2):<br>
        C - r = a<br>
        <br>
        This means that if 'r' is not zero, the 2 iterators can only ever meet on node (C - r), on the first, and on any further occasions.<br>
        <br>
     ");
                WriteLiteral(@"   Now we put one of the pointers back to the first node of the list, and set the speed of rabbit to 1x.<br>
        After both has travelled 'r' nodes, the one left in the cycle will be at the cycle entry node because it was 'r' ahead of it.<br>
        Now the iterator which was put back to the head of the tail travels another k*C distance until it arrives at the cycle entry node since (T = k*C + r), and 'r' has already been covered.<br>
        <br>
        This also means the other iterator left in the cycle also travels another k*C distance.<br>
        Since it started out from the cycle entry node, it must end its journey there as well because 'k' is a positive integer (or zero).<br>
        Intuitively speaking, it will circumvent the cycle completely 'k' times and always arrive back to the cycle entry.<br>
        <br>
        It is more proofish to say that after T covered distance, the put-back pointer must be at cycle entry node.<br>
        At the same time, the other node is at ( (C - r");
                WriteLiteral(@") + r + k*C ) mod C, which is ( (k + 1)*C ) mod C, which is of course zero, which is cycle entry node as well.<br>
    </article>
    <div id=""configuration"">
        <div>
            <label for=""tail"">Tail length: </label>
            <input type=""text"" id=""tail"" name=""tail"">
        </div>
        <div>
            <label for=""cycle"">Cycle length: </label>
            <input type=""text"" id=""cycle"" name=""cycle"">
        </div>
        <div>
            <label for=""time"">Move ms: </label>
            <input type=""text"" id=""move"" name=""move"">
        </div>
        <input type=""button"" id=""restart"" value=""Restart"" onclick=""init()"">
    </div>
    <canvas id=""floyd"" height=""750px""></canvas>
    <script>init()</script>
");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("btnname", async() => {
                WriteLiteral("\r\n\r\n");
            }
            );
            WriteLiteral("\r\n");
            DefineSection("url", async() => {
                WriteLiteral("\r\n\r\n");
            }
            );
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<dynamic> Html { get; private set; }
    }
}
#pragma warning restore 1591
